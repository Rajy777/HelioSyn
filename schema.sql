-- Create a table for user profiles (idempotent)
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,
  email text,
  full_name text,
  updated_at timestamp with time zone
);

-- Set up Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Drop existing policies with the same names to avoid duplicates, then recreate
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING ((SELECT auth.uid()) = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles
  FOR UPDATE USING ((SELECT auth.uid()) = id);

-- Allow service role to insert (for trigger)
DROP POLICY IF EXISTS "Service role can insert profiles" ON public.profiles;
CREATE POLICY "Service role can insert profiles" ON public.profiles
  FOR INSERT WITH CHECK (true);

-- Create a table for Appliances
CREATE TABLE IF NOT EXISTS public.appliances (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users NOT NULL,
  name text NOT NULL,
  power_kw numeric NOT NULL,
  duration numeric DEFAULT 2.0,
  priority text CHECK (priority IN ('Low', 'Medium', 'High', 'Critical')),
  is_flexible boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

ALTER TABLE public.appliances ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own appliances" ON public.appliances;
CREATE POLICY "Users can view own appliances" ON public.appliances
  FOR SELECT USING ((SELECT auth.uid()) = user_id);

DROP POLICY IF EXISTS "Users can insert own appliances" ON public.appliances;
CREATE POLICY "Users can insert own appliances" ON public.appliances
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = user_id);

DROP POLICY IF EXISTS "Users can update own appliances" ON public.appliances;
CREATE POLICY "Users can update own appliances" ON public.appliances
  FOR UPDATE USING ((SELECT auth.uid()) = user_id);

DROP POLICY IF EXISTS "Users can delete own appliances" ON public.appliances;
CREATE POLICY "Users can delete own appliances" ON public.appliances
  FOR DELETE USING ((SELECT auth.uid()) = user_id);

-- Create a table for Uploads (Metadata for CSVs managed in Storage)
CREATE TABLE IF NOT EXISTS public.uploads (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users NOT NULL,
  file_name text NOT NULL,
  file_type text NOT NULL, -- 'solar', 'weather', 'load', 'tariff'
  storage_path text,
  uploaded_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

ALTER TABLE public.uploads ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own uploads" ON public.uploads;
CREATE POLICY "Users can view own uploads" ON public.uploads
  FOR SELECT USING ((SELECT auth.uid()) = user_id);

DROP POLICY IF EXISTS "Users can insert own uploads" ON public.uploads;
CREATE POLICY "Users can insert own uploads" ON public.uploads
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = user_id);

-- Trigger to create profile on signup
-- Replace function if exists to ensure idempotency
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger 
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
BEGIN
  -- Insert profile with error handling
  BEGIN
    INSERT INTO public.profiles (id, email, full_name, updated_at)
    VALUES (
      NEW.id, 
      NEW.email, 
      COALESCE(NEW.raw_user_meta_data->>'full_name', 'User'),
      now()
    )
    ON CONFLICT (id) DO NOTHING;
  EXCEPTION
    WHEN OTHERS THEN
      -- Log error but don't fail the signup
      RAISE WARNING 'Failed to create profile for user %: %', NEW.id, SQLERRM;
  END;
  RETURN NEW;
END;
$$;

-- Create trigger only if not exists: dropping then creating is safe
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
